// The MIT License (MIT)
//
// Copyright (c) 2017 Viktor Oreshkin <imselfish@stek29.rocks>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef CHAPP_COMMON_GROUP_H
#define CHAPP_COMMON_GROUP_H

#include <string>
#include <map>
#include <vector>
#include "Common.hpp"
#include "User.hpp"

namespace Chapp {

    using std::string;
    using std::map;
    using std::vector;

    struct Message;

    class Group {
    public:
        Group() = delete;
        virtual ~Group() = default;

    protected:
        /*!
         * Construct group when all params are known
         * @param gid group id
         * @param gname group name
         * @param users map of users in group by their ids
         */
        Group(int32_t gid, const string& gname, const map<int32_t, User*>& users);

    public:
        /*!
         * Send message coming from uid to all users in group
         * @param uid user id of message author
         * @param msg message to send
         * @return always true
         */
        bool broadcast(int32_t uid, Message msg);

        /*!
         * Invite user to group
         * @param curr_uid inviting user id
         * @param new_uid user id being invited
         * @return true on success
         */
        bool invite(int32_t curr_uid, int32_t new_uid);

        /*!
         * Join group with hash
         * @param uid user joining group
         * @param hash hash, which has to be valid for uid
         * @return true on success
         */
        bool join(int32_t uid, const phash& hash);

        /*!
         * Leave group
         * @param uid id of user leaving
         * @return true on success
         */
        bool leave(int32_t uid);

        /*!
         * List users in group
         * @return Vector of users in group
         */
        // TODO: Optimize by having cached vector => ret const ref to it?
        // vector<MiniUser> list_users() const;

        /*!
         * Create minigroup representing this group
         * @return
         */
        MiniGroup to_minigroup() const {
            // TODO: Optimize by having cached version
            return {
                    .id = id,
                    .name = name,
                    .type = type,
            };
        };

    private:
        /*!
         * Checks if user is in group already
         * @param uid user id being checked
         * @return true if user is in group already
         */
        inline bool has_user(int32_t uid);

        /*!
         * Generate hash for this uid, checked later via check_hash
         * @param uid user id
         * @return hash guaranteed to be valid for this uid
         */
        virtual phash gen_hash(int32_t uid) const = 0;

        /*!
         * Check hash for this uid, probably generated via gen_hash
         * @param uid user id
         * @param hash hash recieved from user
         * @return true if hash is valid and user can join, false if not
         */
        virtual bool check_hash(int32_t uid, const phash& hash) const = 0;

        /*!
         * Create GroupInvite for user
         * @param uid id of user
         * @return Invite valid for user
         */
        GroupInvite make_invite(int32_t uid) const {
            return {
                    .hash = gen_hash(uid),
                    .for_uid = uid,
                    .group = to_minigroup(),
            };
        };

    public:
        int32_t id;
        string name;
        GroupType type;


    protected:
        map<int32_t, User*> users_by_id;

    };

    class PublicGroup : public Group {
    private:
        friend class GroupFactory; // Only allow to create groups via factory

        /*!
         * Create group
         * @param gid group id, likely generated by db
         * @param gname group name
         * @param creator user creating the group
         */
        PublicGroup(int32_t gid, const string& gname, User* creator);

        /*!
         * Construct group from DB
         * @param gid group id, likely generated by db
         * @param gname group name
         * @param users ids:users in the group
         */
        PublicGroup(int32_t gid, const string& gname, const map<int32_t, User*>& users);

    private:
        /*!
         * Generate hash for uid
         * @return 0-filled hash
         */
        phash gen_hash(int32_t uid) const override;

        /*!
         * Check hash for uid
         * @return always true
         */
        bool check_hash(int32_t uid, const phash& hash) const override;

    };

    class ProtectedGroup : public Group {
    private:
        friend class GroupFactory; // Only allow to create groups via factory

        /*!
         * Create group
         * @param gid group id, likely generated by db
         * @param gname group name
         * @param creator user creating group
         * @param hash group password hash
         */
        ProtectedGroup(int32_t gid, const string& gname, User* creator, phash hash);

        /*!
         * Construct group
         * @param gid group id, likely generated by db
         * @param gname group name
         * @param users ids:users in the group
         * @param ghash password hash
         */
        ProtectedGroup(int32_t gid, const string& gname, const map<int32_t, User*>& users, phash hash);

    private:
        /*!
         * Generate hash
         * @return groups password hash, common for all users
         */
        phash gen_hash(int32_t uid) const override;

        /*!
         * Check hash
         * @return true if hash matches group's hash
         */
        bool check_hash(int32_t uid, const phash& hash) const override;

        phash hash;

    };

    class PrivateGroup : public Group {
    private:
        friend class GroupFactory; // Only allow to create groups via factory

        /*!
         * Create group
         * @param gid group id, likely generated by db
         * @param gname group name
         * @param creator user creating group
         */
        PrivateGroup(int32_t gid, const string& gname, User* creator);

        /*!
         * Construct group
         * @param gid group id, likely generated by db
         * @param gname group name
         * @param users ids:users in the group
         * @param ghash group's hash
         */
        PrivateGroup(int32_t gid, const string& gname, const map<int32_t, User*>& users, phash ghash);

    private:
        /*!
         * Generate hash
         * @return hash valid for uid
         */
        phash gen_hash(int32_t uid) const override;

        /*!
         * Check hash
         * @return true if hash is valid for this uid
         */
        bool check_hash(int32_t uid, const phash& hash) const override;

        phash hash;

    };

}

#endif
